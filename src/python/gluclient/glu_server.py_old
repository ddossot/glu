
"""
Definition of the GluServer class.

"""

import json
import urllib
import httplib

from gluclient.glu_client_exception import GluClientException
from gluclient.glu_component        import GluComponent
from gluclient.glu_resource         import GluResource

class GluServer(object):
    """
    Used by the client to encapsulate all communication with the server.

    """
    # The keys to the server's meta data dictionary.
    __CODE_URI_KEY      = "code"
    __DOC_URI_KEY       = "doc"
    __NAME_KEY          = "name"
    __RESOURCE_URI_KEY  = "resource"
    __STATIC_URI_KEY    = "static"
    __VERSION_KEY       = "version"

    __META_URI          = "/"    # Location of the server's root directory (meta info)

    __server_uri        = None   # Stores the URI of the server to which we connect
    __component_uri     = None   # The URI of where the components can be found
    __doc_uri           = None   # The URI of the server documentation
    __name              = None   # The name of the server
    __resource_uri      = None   # The URI where resources can be found
    __static_uri        = None   # The URI for static content
    __version           = None   # The version string of the server
    __doc               = None   # A cache for the servers's doc string
    __resources         = None   # A cache for the resource-name-plus dictionary
    __components        = None   # A cache for the component-name-plus dictionary

    class __MyOpener(urllib.URLopener):
        """
        Helper class allowing us to create our own URL opener.

        We need to use our own opener, since we have to have more 
        control over methods and headers than what we would get
        with just directly using urlopen() from urllib.

        """
        error_info = None

        def http_error_default(self, url, fp, errcode, errmsg, headers):
            """
            Specify our own error handler.

            We just store the error information and make it available in a
            shared variable to the caller. Not particularly thread-safe,
            I must say.

            """
            self.error_info = (errcode, errmsg, fp.read())

        def add_msg(self, message):
            """
            Add a message body.

            This also sets the content-length header, which is only required
            if we send data with the request.

            @param message:     A request body.
            @type message:      string

            """
            if message:
                self._my_msg = message
                self.addheader('Content-length', str(len(message)))

        def send(self, url):
            """
            Send the actual request to the server.

            @param url:     The absolute URL for the request.
            @type url:      string

            @return:        Whatever data was sent back in response.
            @type:          string

            """
            if hasattr(self, "_my_msg"):
                msg = self._my_msg
            else:
                msg = None
            return self.open(url, msg)


    def _send(self, url, data=None):
        """
        A sending method that uses our own URL opener.

        Note that we will send all messages with application/json as
        the accept header. JSON is our preferred mode of serializing
        data.

        @param url:     The relative (!) URL on that server to which
                        the request shoudl be sent.
        @type url:      string

        @param data:    Any data object, which will be serialized to
                        JSON if specified.
        @type data:     object

        @return:        Any data that may have been received from the
                        server.
        @rtype:         string

        """
        opener = self.__MyOpener()
        opener.addheader('Connection', 'close')
        opener.addheader('Accept', 'application/json')
        if data:
            opener.add_msg(json.dumps(data))
        stream = opener.send(self.__server_uri + url)
        
        if stream:
            return stream.read()

        raise GluClientException("Network issue: " + str(opener.error_info))

    def _json_send(self, url, data=None):
        """
        Assume that the returning data is JSON encoded and deserialize.

        This is just a wrapper around _send(), which deserializes
        the return data.

        @param url:     Absolute URL to which the request should be sent.
        @type url:      string

        @param data:    Some object that should be sent.
        @type data:     object

        @return:        Any data that may have been received from the
                        server.
        @rtype:         string

        """
        d = self._send(url, data)
        return json.loads(d)


    # --------------------------------------------
    # Public interface
    # --------------------------------------------

    def __init__(self, server_uri):
        """
        Initialize the server class.

        Send a request for the base meta information to the
        server and remember some of the information that was
        returned.

        It's important to note that the meta information of
        the server is retrieved and cached once. If this
        information should subsequently change, this server
        object won't know about it.

        """
        self.__server_uri    = server_uri

        d                    = self._json_send(self.__META_URI)

        try:
            self.__component_uri = d[self.__CODE_URI_KEY]
            self.__doc_uri       = d[self.__DOC_URI_KEY]
            self.__name          = d[self.__NAME_KEY]
            self.__resource_uri  = d[self.__RESOURCE_URI_KEY]
            self.__static_uri    = d[self.__STATIC_URI_KEY]
            self.__version       = d[self.__VERSION_KEY]
        except KeyError, e:
            raise GluClientException("Server error: Expected key '%s' missing in server meta data." % str(e))

    def _create_resource(self, uri, rdict):
        """
        Create a new resource.

        Clients should NOT use this method directly. Instead, they
        should use obtain a resource template from a component and
        then call create_resource() on that template.

        @param uri:     Component URI to which this resource description
                        should be posted.
        @type uri:      string

        @param rdict:   The completed dictionary to be posted to
                        this components URI.
        @type rdict:    dict.

        """
        return self._json_send(uri, rdict)

    def get_server_uri(self):
        """
        Return the URI of the server to which we are connected.

        @return:        The server's URI.
        @rtype:         string

        """
        return self.__server_uri

    def get_server_version(self):
        """
        Return the version string contained in the server's meta data.

        @return:        The server's version.
        @rtype:         string

        """
        return self.__version

    def get_server_name(self):
        """
        Return the name string contained in the server's meta data.

        @return:        The server's name.
        @rtype:         string

        """
        return self.__name

    def get_server_doc(self):
        """
        Return the doc string for this server.

        Since the doc has its own URI and is potentially longer,
        we are sending an extra request right here, unless the
        information is cached already.

        @return:        The server's doc string.
        @rtype:         string

        """
        if not self.__doc:
            self.__doc = self._json_send(self.__doc_uri)
        return self.__doc

    def get_all_resource_names(self):
        """
        Return the list of all resource names.

        This does not query the meta data for each resource.
        If that is needed, use a separate get_resource()
        call for each resource.

        Alternatively, one may use get_all_resource_names_plus()
        to get at least description string and URI of each
        resource as well.

        The information is cached, thus only the first request
        to get_all_resource_names() or get_all_resource_names_plus()
        results in a request to the server.

        @return:        List of resource names.
        @rtype:         list

        """
        if not self.__resources:
            self.__resources = self._json_send(self.__resource_uri)
        return self.__resources.keys()

    def get_all_resource_names_plus(self):
        """
        Return dictionary with all high-level meta info about all resources.

        This does not query the meta data for each resource.
        If that is needed, use a separate get_resource()
        call for each resource.

        Returns a dictionary keyed by the resource name and
        containing further dictionaries, each containing a 'desc'
        and 'uri' element.

        The information is cached.

        @return:        Dictionary with high-level resource info.
        @rtype:         dict

        """
        if not self.__resources:
            self.__resources = self._json_send(self.__resource_uri)
        return self.__resources

    def get_all_component_names(self):
        """
        Return the list of all component names.

        This does not query the meta data for each component.
        If that is needed, use a separate get_component()
        call for each component.

        Alternatively, one may use get_all_component_names_plus()
        to get at least description string and URI of each
        component as well.

        The information is cached, thus only the first request
        to get_all_component_names() or get_all_component_names_plus()
        results in a request to the server.

        @return:        List of component names.
        @rtype:         list

        """
        if not self.__components:
            self.__components = self._json_send(self.__component_uri)
        return self.__components.keys()

    def get_all_component_names_plus(self):
        """
        Return dictionary with all high-level meta info about all component.

        This does not query the meta data for each component.
        If that is needed, use a separate get_component()
        call for each component.

        Returns a dictionary keyed by the component name and
        containing further dictionaries, each containing a 'desc'
        and 'uri' element.

        The information is cached.

        @return:        Dictionary with high-level component info.
        @rtype:         dict

        """
        if not self.__components:
            self.__components = self._json_send(self.__component_uri)
        return self.__components

    def get_component(self, name):
        """
        Return a GluComponent object for the specified component.

        @param name:    Name of component.
        @type name:     string

        @return:        GluComponent for the specified component.
        @rtype:         GluComponent

        """
        d = self._json_send(self.__component_uri + "/" + name)
        return GluComponent(self, d)

    def get_resource(self, name):
        """
        Return a GluResource object for the specified resource.

        @param name:    Name of resource.
        @type name:     string

        @return:        GluResource for the specified resource.
        @rtype:         GluResource

        """
        d = self._json_send(self.__resource_uri + "/" + name)
        return GluResource(self, d)

